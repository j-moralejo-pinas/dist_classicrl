name: Configure repository
on:
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  apply:
    # Optional safety gate. Keep if you stored ADMIN_TOKEN in env "prod".
    environment: main
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      # 1) Core settings (only non-defaults)
      - name: Core repo settings
        id: core
        env:
          GH_TOKEN: ${{ secrets.ADMIN_TOKEN }}
          REPO_NEW_NAME: dist_classicrl
          REPO_DESC: This library contains a distributed implementation of classical q-learning. It may contain more implementations in the future.
          REPO_WEB: ""   # leave empty to skip homepage
        run: |
          set -euo pipefail

          BODY=$(jq -n \
            --arg name "$REPO_NEW_NAME" \
            --arg desc "$REPO_DESC" \
            '{name:$name, description:$desc,
              has_wiki:false,
              allow_auto_merge:true,
              allow_update_branch:true,
              delete_branch_on_merge:true}')

          if [ -n "${REPO_WEB:-}" ]; then
            BODY=$(echo "$BODY" | jq --arg home "$REPO_WEB" '. + {homepage:$home}')
          fi

          gh api --method PATCH -H "Accept: application/vnd.github+json" \
            "/repos/$GITHUB_REPOSITORY" \
            --input <(printf '%s' "$BODY")

          # Get fresh slug after possible rename. Write to outputs and env.
          REPO_SLUG=$(gh api "/repos/$GITHUB_REPOSITORY" -H "Accept: application/vnd.github+json" -q .full_name)
          echo "slug=$REPO_SLUG" >> "$GITHUB_OUTPUT"
          echo "REPO_SLUG=$REPO_SLUG" >> "$GITHUB_ENV"

      # 2) Topics
      - name: Topics
        env:
          GH_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          set -euo pipefail
          # Fallback if env not set for any reason
          REPO_SLUG="${REPO_SLUG:-$GITHUB_REPOSITORY}"

          # Set your topics here. Use [] to clear.
          REPO_TOPICS_JSON='[]'

          gh api --method PUT \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/$REPO_SLUG/topics" \
            --input <(jq -n --argjson names "$REPO_TOPICS_JSON" '{names:$names}')

      # 3) Workflow token permissions
      - name: Workflow permissions
        env:
          GH_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          set -euo pipefail
          REPO_SLUG="${REPO_SLUG:-$GITHUB_REPOSITORY}"

          gh api -X PUT "/repos/$REPO_SLUG/actions/permissions/workflow" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            --input <(jq -n '{default_workflow_permissions:"write"}')

      # 4) Rulesets (correct schema). Never call /repos//rulesets again.
      - name: Create or update rulesets
        env:
          GH_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          set -euo pipefail
          set -x
      
          # Derive slug robustly. Prefer env set earlier, else fall back.
          REPO_SLUG="${REPO_SLUG:-$GITHUB_REPOSITORY}"
          echo "Using REPO_SLUG=$REPO_SLUG"
      
          # Show auth and who we are
          gh auth status || true
          gh api -i -H "Accept: application/vnd.github+json" \
                   -H "X-GitHub-Api-Version: 2022-11-28" \
                   "/rate_limit" || true
      
          # Prove the repo exists and we can read it
          echo "Probing repo metadata..."
          gh api -i -H "Accept: application/vnd.github+json" \
                   -H "X-GitHub-Api-Version: 2022-11-28" \
                   "/repos/$REPO_SLUG" || true
      
          # Probe rulesets endpoint and capture status + body
          echo "Probing rulesets endpoint..."
          PROBE_OUT=$(gh api -i -H "Accept: application/vnd.github+json" \
                              -H "X-GitHub-Api-Version: 2022-11-28" \
                              "/repos/$REPO_SLUG/rulesets" || true)
          echo "$PROBE_OUT"
      
          STATUS=$(printf '%s' "$PROBE_OUT" | awk 'BEGIN{s=""} /^HTTP/{s=$2} END{print s}')
          BODY=$(printf '%s' "$PROBE_OUT" | awk 'BEGIN{p=0} /^HTTP/{p=0} /^$/{p=1;next} {if(p)print}')
      
          echo "Rulesets HTTP status: ${STATUS:-unknown}"
          if [ "${STATUS:-}" != "200" ]; then
            echo "Rulesets list failed. Status=$STATUS" >&2
            echo "Response body:" >&2
            printf '%s\n' "$BODY" >&2
            exit 1
          fi
      
          # Helper to find id by name
          find_ruleset_id_by_name() {
            local NAME="$1"
            gh api "/repos/$REPO_SLUG/rulesets" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              | jq -r ".[] | select(.name==\"$NAME\") | .id" | head -n1
          }
      
          # Build a checks array like [{"context":"format"}, ...]
          mk_checks_json() {
            jq -R -s 'split("\n") | map(select(length>0)) | map({context:.})'
          }
      
          upsert_ruleset() {
            local NAME="$1" BRANCH="$2" ALLOWED_MERGES_JSON="$3"; shift 3
            local CHECKS_LIST=("$@")
      
            local CHECKS_JSON
            CHECKS_JSON=$(printf '%s\n' "${CHECKS_LIST[@]}" | mk_checks_json)
      
            RULES=$(jq -n \
              --argjson allowed "$ALLOWED_MERGES_JSON" \
              --argjson checks "$CHECKS_JSON" '
              [
                { "type": "deletion" },
                {
                  "type": "pull_request",
                  "parameters": {
                    "dismiss_stale_reviews_on_push": true,
                    "require_code_owner_review": true,
                    "required_approving_review_count": 1,
                    "allowed_merge_methods": $allowed
                  }
                },
                {
                  "type": "required_status_checks",
                  "parameters": {
                    "do_not_enforce_on_create": false,
                    "required_status_checks": $checks,
                    "strict_required_status_checks_policy": true
                  }
                },
                { "type": "non_fast_forward" }
              ]')
      
            BODY=$(jq -n \
              --arg name "$NAME" \
              --arg branch "refs/heads/$BRANCH" \
              --argjson rules "$RULES" '
              {
                name: $name,
                target: "branch",
                enforcement: "active",
                conditions: { ref_name: { include: [$branch], exclude: [] } },
                rules: $rules
              }')
      
            ID=$(find_ruleset_id_by_name "$NAME" || true)
            if [ -n "${ID:-}" ]; then
              echo "Updating ruleset $NAME ($ID)"
              gh api -i -X PATCH "/repos/$REPO_SLUG/rulesets/$ID" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                --input <(printf '%s' "$BODY")
            else
              echo "Creating ruleset $NAME"
              gh api -i -X POST "/repos/$REPO_SLUG/rulesets" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                --input <(printf '%s' "$BODY")
            fi
          }
      
          # Main: Merge only, checks: check-source-branch, format, code-quality, test
          upsert_ruleset "Main" "main" \
            "$(jq -n '["merge"]')" \
            "check-source-branch" "format" "code-quality" "test"
      
          # Dev: Merge + Squash, checks: format, test
          upsert_ruleset "Dev" "dev" \
            "$(jq -n '["merge","squash"]')" \
            "format" "test"
